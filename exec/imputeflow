#!/usr/bin/env Rscript

suppressPackageStartupMessages({
  library(optparse)
  library(cli)
  library(imputeflow)
})

options(cli.progress_show_after = 0, cli.progress_clear = FALSE)

argv <- commandArgs(trailingOnly = TRUE)

if (length(argv) == 0 || argv[1] %in% c("-h", "--help")) {
  cat("
Usage: imputeflow <method> [options]

Methods:
  mean       Impute using column-wise mean
  median     Impute using column-wise median
  mode       Impute using column-wise mode
  knn        Impute using k-Nearest Neighbors
  drf        Impute using Distributed Random Forest (H2O)

Use --help with a method to see its options, e.g.:
  imputeflow mean --help
")
  quit(status = if (length(argv) == 0) 2 else 0)
}

method <- tolower(argv[1])
args   <- argv[-1]

#' Parse a comma-separated list of column names
#' @keywords internal
#' @noRd
parse_cols <- function(x) {
  if (is.null(x) || is.na(x) || !nzchar(x)) return(NULL)
  cols <- strsplit(x, ",", fixed = TRUE)[[1]]
  cols <- trimws(cols)
  cols <- cols[nzchar(cols)]
  unique(cols)
}

#' Read CSV from stdin
#' @keywords internal
#' @noRd
read_stdin_csv <- function(verbose = FALSE, spinner = NULL) {
  if (!requireNamespace("readr", quietly = TRUE)) {
    stop("Package 'readr' is required for CLI IO. Install it first.", call. = FALSE)
  }
  df <- readr::read_csv(file("stdin"), show_col_types = FALSE)

  if (is.function(df)) {
    cli::cli_abort(c(
      "x Internal error: read_stdin_csv() received a function, not data.",
      "i Did you accidentally write {.code df <- readr::read_csv} without parentheses?",
      "i It must be {.code df <- readr::read_csv(file('stdin'), show_col_types = FALSE)}"
    ))
  }

  as.data.frame(df, stringsAsFactors = FALSE)
}

#' Write CSV to stdout
#' @keywords internal
#' @noRd
write_stdout_csv <- function(df, verbose = FALSE, spinner = NULL) {
  if (!requireNamespace("readr", quietly = TRUE)) {
    stop("Package 'readr' is required for CLI IO. Install it first.", call. = FALSE)
  }
  readr::write_csv(df, stdout())
  invisible(df)
}

#' Common CLI options for fit/apply style commands
#' @keywords internal
#' @noRd
common_fit_apply_opts <- function() {
  list(
    make_option(c("--mode"), type = "character", default = "fit-apply",
                help = "One of: fit, apply, fit-apply (default)"),
    make_option(c("--save-spec"), type = "character", default = NULL,
                help = "Path to save the fitted imputer spec (fit or fit-apply)"),
    make_option(c("--load-spec"), type = "character", default = NULL,
                help = "Path to load an existing imputer spec (apply)"),
    make_option(c("-c", "--cols"), type = "character", default = NULL,
                help = "Comma-separated columns to impute (default: auto/all)"),
    make_option(c("--exclude-predictors"), type = "character", default = NULL,
                help = "Comma-separated predictor columns to EXCLUDE (kNN/DRF)"),
    make_option(c("--train-frac"), type = "double", default = 1.0,
                help = "Fraction of rows to use as training (0-1] if no train rows/mask"),
    make_option(c("--train-rows"), type = "character", default = NULL,
                help = "Path to newline-separated 1-based row indices for training"),
    make_option(c("--train-mask"), type = "character", default = NULL,
                help = "Path to CSV containing a boolean mask column for training rows"),
    make_option(c("--mask-col"), type = "character", default = NULL,
                help = "Column name in --train-mask to use (default: first logical)"),
    make_option(c("--seed"), type = "integer", default = 1),
    make_option(c("--round"), type = "integer", default = NA,
                help = "Digits for final rounding (post-processing). Omit for no rounding."),
    make_option(c("--quiet"), action = "store_true", default = FALSE)
  )
}

#' Print a compact “columns” banner to CLI
#' @keywords internal
#' @noRd
.print_cols_banner <- function(df, cols) {
  target_cols <- if (!is.null(cols)) cols else names(df)
  if (!is.null(cols)) {
    max_cols <- 3
    if (length(cols) > max_cols) {
      short_cols <- paste(c(cols[1:max_cols], "..."), collapse = ", ")
      cli::cli_alert_info("Columns      : {short_cols} ({length(cols)} total)")
    } else {
      cli::cli_alert_info("Columns      : {paste(cols, collapse = ', ')}")
    }
  } else {
    cli::cli_alert_info("Columns        : All Columns ({length(target_cols)} total)")
  }
}

#' Begin redirecting base R stdout/messages to terminal stderr
#' @keywords internal
#' @noRd
redirect_start <- function() {
  old_out <- sink.number()
  old_msg <- sink.number(type = "message")
  sink(stderr())
  sink(stderr(), type = "message")
  list(old_out = old_out, old_msg = old_msg)
}

#' Stop redirecting and restore previous sinks
#' @keywords internal
#' @noRd
redirect_stop <- function(state) {
  while (sink.number(type = "message") > state$old_msg) {
    try(sink(type = "message"), silent = TRUE)
  }
  while (sink.number() > state$old_out) {
    try(sink(), silent = TRUE)
  }
}

# small helper to print the same arrowed per-column line as DRF
.per_col_line <- function(colname) {
  sym <- cli::symbol
  cat(
    paste0(
      cli::col_silver(sym$arrow_right, " "),
      cli::col_silver("imputing column : "),
      cli::col_cyan(colname),
      "\n"
    ),
    file = stderr()
  )
  flush.console()
}

#' Run the mean CLI subcommand (with progress bar)
#' @keywords internal
#' @noRd
run_mean <- function() {
  option_list <- c(common_fit_apply_opts())
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  cli::cli_h1("imputeflow")
  cli::cli_alert_info("Method  : MEAN")
  cli::cli_alert_info("Mode    : {opt$mode} | Training fraction (fallback): {opt$`train-frac`}")

  df   <- read_stdin_csv(verbose = !opt$quiet)
  cols <- parse_cols(opt$cols)
  .print_cols_banner(df, cols)

  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(
    target_cols,
    function(nm) is.numeric(df[[nm]]) && imputeflow:::needs_imputation(df[[nm]]),
    logical(1)
  )]
  mode  <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  t0 <- Sys.time()
  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    spec <- imputeflow::fit_mean_spec(df, cols = eligible, train_rows = train_rows)
    # visual-only progress for fitting
    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Fitting mean spec", total = length(spec$cols))
      for (nm in spec$cols) cli::cli_progress_update(id = bar_id)
      cli::cli_progress_done(id = bar_id)
    }
    saveRDS(spec, opt$`save-spec`)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")
    invisible(NULL)
  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    spec <- readRDS(opt$`load-spec`)
    out_full <- imputeflow::apply_mean_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        if (!nm %in% names(out)) { cli::cli_progress_update(id = bar_id); next }
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    write_stdout_csv(out, verbose = !opt$quiet)
  } else {
    spec <- imputeflow::fit_mean_spec(df, cols = eligible, train_rows = train_rows)
    out_full <- imputeflow::apply_mean_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    if (!is.null(opt$`save-spec`)) {
      saveRDS(spec, opt$`save-spec`)
      cli::cli_alert_info("Saved spec to {opt$`save-spec`}.")
    }
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  dt <- round(difftime(Sys.time(), t0, units = "secs"), 2)
  cli::cli_alert_success("Completed mean in {dt} seconds.")
}

#' Run the median CLI subcommand (with progress bar)
#' @keywords internal
#' @noRd
run_median <- function() {
  option_list <- c(common_fit_apply_opts())
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  df <- read_stdin_csv(verbose = !opt$quiet)
  cli::cli_h1("imputeflow")
  cli::cli_alert_info("Method  : MEDIAN")
  cli::cli_alert_info("Mode    : {opt$mode} | Training fraction (fallback): {opt$`train-frac`}")

  cols <- parse_cols(opt$cols)
  .print_cols_banner(df, cols)

  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(
    target_cols,
    function(nm) is.numeric(df[[nm]]) && imputeflow:::needs_imputation(df[[nm]]),
    logical(1)
  )]
  mode  <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  t0 <- Sys.time()
  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    spec <- imputeflow::fit_median_spec(df, cols = eligible, train_rows = train_rows)
    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Fitting median spec", total = length(spec$cols))
      for (nm in spec$cols) cli::cli_progress_update(id = bar_id)
      cli::cli_progress_done(id = bar_id)
    }
    saveRDS(spec, opt$`save-spec`)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")
  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    spec <- readRDS(opt$`load-spec`)
    out_full <- imputeflow::apply_median_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEDIAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        if (!nm %in% names(out)) { cli::cli_progress_update(id = bar_id); next }
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    write_stdout_csv(out, verbose = !opt$quiet)
  } else {
    spec <- imputeflow::fit_median_spec(df, cols = eligible, train_rows = train_rows)
    out_full <- imputeflow::apply_median_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEDIAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    if (!is.null(opt$`save-spec`)) {
      saveRDS(spec, opt$`save-spec`)
      cli::cli_alert_info("Saved spec to {opt$`save-spec`}.")
    }
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  dt <- round(difftime(Sys.time(), t0, units = "secs"), 2)
  cli::cli_alert_success("Completed median in {dt} seconds.")
}

#' Run the knn CLI subcommand (with progress bar + themed colors)
#' @keywords internal
#' @noRd
run_knn <- function() {
  option_list <- c(
    common_fit_apply_opts(),
    make_option(c("--neighbors"), type = "integer", default = 5)
  )
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  # Make bars show immediately; render to stderr
  old_opts <- options(cli.progress_show_after = 0, cli.progress_clear = FALSE)
  on.exit(options(old_opts), add = TRUE)
  try(options(cli.progress_output = "stderr"), silent = TRUE)

  # ── Theme (vivid|minimal) + GREEN progress bar ────────────────────────────
  style <- tolower(Sys.getenv("IMPUTEFLOW_STYLE", "vivid"))
  theme <- switch(
    style,
    minimal = list(
      ".impute .label"   = list(),
      ".impute .val"     = list("font-weight" = "bold"),
      ".impute .method"  = list(bold = TRUE),
      ".impute .mode"    = list(bold = TRUE, color = "blue"),
      ".impute .columns" = list(bold = TRUE),
      ".impute .col"     = list(bold = TRUE),
      ".impute .num"     = list(color = "blue"),
      ".impute .mem"     = list(color = "magenta"),
      # progress bar styling (green)
      ".progress-bar .bar"          = list(color = "green"),
      ".progress-bar .bar-complete" = list(color = "green"),
      ".progress-bar .current"      = list(color = "green")
    ),
    # vivid (default)
    list(
      ".impute h1"       = list(color = "#268BD2"),   # blue header
      ".impute .label"   = list(color = "#839496"),   # base0 (soft gray)
      ".impute .val"     = list(color = "#FDF6E3", "font-weight" = "bold"),
      ".impute .method"  = list(color = "#CB4B16", "font-weight" = "bold"), # orange
      ".impute .ntrees"  = list(color = "#B58900", "font-weight" = "bold"), # yellow
      ".impute .mdepth"  = list(color = "#B58900", "font-weight" = "bold"),
      ".impute .srate"   = list(color = "#B58900", "font-weight" = "bold"),
      ".impute .treer"   = list(color = "#B58900", "font-weight" = "bold"),
      ".impute .mode"    = list(color = "#2AA198", "font-weight" = "bold"), # cyan
      ".impute .columns" = list(color = "#EEE8D5"),                         # light bg
      ".impute .col"     = list(color = "#268BD2", "font-weight" = "bold"), # blue
      ".impute .num"     = list(color = "#859900", "font-weight" = "bold"), # green
      ".impute .mem"     = list(color = "#D33682", "font-weight" = "bold"), # magenta
      ".impute .ok"      = list(color = "#859900"),  # green ok
      ".impute .warn"    = list(color = "#B58900"),  # yellow warn
      ".progress-bar .bar"          = list(color = "#859900"),
      ".progress-bar .bar-complete" = list(color = "#859900"),
      ".progress-bar .current"      = list(color = "#859900")
    )
  )
  div_id <- cli::cli_div(class = "impute", theme = theme)
  on.exit(cli::cli_end(div_id), add = TRUE)

  # Header
  .line <- if (isTRUE(l10n_info()[["UTF-8"]])) "─" else "-"
  hdr <- cli::rule(left = cli::col_cyan(cli::style_bold("imputeflow")), line = .line, col = "cyan")
  cat(hdr, "\n", file = stderr(), sep = "")
  cli::cli_alert_info("Method  : {.method kNN}")
  cli::cli_alert_info("Mode    : {.mode {opt$mode}} | Neighbors: {.num {opt$neighbors}} | Training fraction (fallback): {.num {opt$`train-frac`}}")

  df <- read_stdin_csv(verbose = !opt$quiet)

  cols <- parse_cols(opt$cols)
  excl <- parse_cols(opt$`exclude-predictors`)

  # Themed columns banner
  shown <- if (!is.null(cols)) cols else names(df)
  short <- if (length(shown) > 3L) paste0(paste(shown[1:3], collapse = ", "), ", ...") else paste(shown, collapse = ", ")
  cli::cli_alert_info("Columns : {.columns {short}} ({.num {length(shown)}} total)")

  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )

  numeric_cols <- names(df)[vapply(df, is.numeric, logical(1))]
  if (!is.null(cols)) numeric_cols <- intersect(numeric_cols, cols)
  eligible <- numeric_cols[vapply(df[numeric_cols], function(x) any(is.na(x)), logical(1))]
  mode  <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  t0 <- Sys.time()

  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    pb <- cli::cli_progress_bar("Fitting (kNN)", total = 2, name = "kNN")

    spec <- imputeflow::fit_knn_spec(
      df, cols = eligible, neighbors = opt$neighbors, train_rows = train_rows,
      exclude_predictors = excl
    )
    cli::cli_progress_update(id = pb)

    saveRDS(spec, opt$`save-spec`)
    cli::cli_progress_update(id = pb)
    cli::cli_progress_done(id = pb)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")
    invisible(NULL)

  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    pb <- cli::cli_progress_bar("Imputing (kNN)", total = 3, name = "kNN")

    spec <- readRDS(opt$`load-spec`);                     cli::cli_progress_update(id = pb)
    out  <- imputeflow::apply_knn_spec(df, spec, round_digits = opt$round); cli::cli_progress_update(id = pb)
    write_stdout_csv(out, verbose = !opt$quiet);          cli::cli_progress_update(id = pb)
    cli::cli_progress_done(id = pb)

  } else { # fit-apply (tick once per column; no per-column messages)
    n_cols <- length(eligible)
    pb <- cli::cli_progress_bar("Imputing (kNN)", total = max(n_cols, 1L), name = "kNN")

    out <- df
    if (n_cols == 0L) {
      cli::cli_progress_update(id = pb)
      cli::cli_progress_done(id = pb)
      write_stdout_csv(out, verbose = !opt$quiet)
      return(invisible(NULL))
    }

    for (nm in eligible) {
      spec_one <- imputeflow::fit_knn_spec(
        out, cols = nm, neighbors = opt$neighbors, train_rows = train_rows,
        exclude_predictors = excl
      )
      out_one <- imputeflow::apply_knn_spec(out, spec_one, round_digits = opt$round)
      if (nm %in% names(out_one)) out[[nm]] <- out_one[[nm]]
      cli::cli_progress_update(id = pb)
    }

    cli::cli_progress_done(id = pb)
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  dt <- round(difftime(Sys.time(), t0, units = "secs"), 2)
  cli::cli_alert_success("Completed kNN in {dt} seconds.")
}


#' Run the drf CLI subcommand (styled theme + single GREEN bar + timer)
#' @keywords internal
#' @noRd
run_drf <- function() {
  # Collect argv and strip any leading subcommand tokens like "drf" or "impute drf"
  get_argv <- function() {
    if (exists("args", inherits = FALSE)) args else commandArgs(trailingOnly = TRUE)
  }
  argv <- get_argv()
  while (length(argv) && argv[1L] %in% c("impute", "drf")) {
    argv <- argv[-1L]
  }

  option_list <- c(
    common_fit_apply_opts(),
    make_option(c("--ntrees"), type = "integer", default = 50),
    make_option(c("--max-depth"), type = "integer", default = 10),
    make_option(c("--min-rows"), type = "integer", default = 5),
    make_option(c("--sample-rate"), type = "double", default = 0.8),
    make_option(c("--col-sample-rate-per-tree"), type = "double", default = 0.8),
    make_option(c("--balance-classes"), action = "store_true", default = FALSE),
    make_option(c("--h2o-threads"), type = "integer", default = NA_integer_),
    make_option(c("--h2o-mem"), type = "character", default = NULL),
    make_option(
      c("--fallback"), type = "character", default = "none",
      help = "Fallback if DRF doesn't reduce missingness: none|mean|median|mode"
    ),
    make_option(c("--h2o-shutdown"), action = "store_true", default = FALSE)
  )
  opt <- parse_args(OptionParser(option_list = option_list), args = argv)

  if (!is.null(opt$`save-spec`) || !is.null(opt$`load-spec`) || tolower(opt$mode) != "fit-apply") {
    cli::cli_abort(c(
      "x DRF currently supports only {.code --mode fit-apply} in a single session.",
      "i Spec save/load for DRF is not yet supported."
    ))
  }

  # Progress: show immediately on stderr; keep stdout clean; silence readr bars
  old_opts <- options(
    cli.progress_show_after = 0,
    cli.progress_clear      = FALSE,
    cli.progress_output     = "stderr",
    cli.num_colors          = 256,
    crayon.enabled          = TRUE,
    readr.show_progress     = FALSE
  )
  on.exit(options(old_opts), add = TRUE)

  # ── Theme (vivid|minimal) + GREEN progress bar ────────────────────────────
  style <- tolower(Sys.getenv("IMPUTEFLOW_STYLE", "vivid"))
  theme <- switch(
    style,
    minimal = list(
      ".impute .label"   = list(),
      ".impute .val"     = list("font-weight" = "bold"),
      ".impute .method"  = list(bold = TRUE),
      ".impute .mode"    = list(bold = TRUE, color = "blue"),
      ".impute .columns" = list(bold = TRUE),
      ".impute .col"     = list(bold = TRUE),
      ".impute .num"     = list(color = "blue"),
      ".impute .mem"     = list(color = "magenta"),
      ".progress-bar .bar"          = list(color = "green"),
      ".progress-bar .bar-complete" = list(color = "green"),
      ".progress-bar .current"      = list(color = "green")
    ),
    list(
      ".impute h1"       = list(color = "#6A5ACD", "font-weight" = "bold"),
      ".impute .label"   = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .val"     = list(color = "#F8F8FF", "font-weight" = "bold"),
      ".impute .method"  = list(color = "#FF69B4", "font-weight" = "bold"),
      ".impute .round"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .ntrees"  = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .mdepth"  = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .srate"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .treer"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .mode"    = list(color = "#7FFFD4", "font-weight" = "bold"),
      ".impute .columns" = list(color = "#F8F8FF"),
      ".impute .col"     = list(color = "#FFD700", "font-weight" = "bold"),
      ".impute .num"     = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .mem"     = list(color = "#9370DB", "font-weight" = "bold"),
      ".impute .ok"      = list(color = "#32CD32"),
      ".impute .warn"    = list(color = "#FFA07A"),
      ".progress-bar .bar"          = list(color = "#32CD32"),
      ".progress-bar .bar-complete" = list(color = "#32CD32"),
      ".progress-bar .current"      = list(color = "#32CD32")
    )
  )
  div_id <- cli::cli_div(class = "impute", theme = theme)
  on.exit(cli::cli_end(div_id), add = TRUE)

  # Guard: --h2o-mem must include a G suffix (e.g. 8G). If provided and invalid, abort early.
  if (!is.null(opt$`h2o-mem`) && nzchar(opt$`h2o-mem`)) {
    mem_str <- trimws(opt$`h2o-mem`)
    if (!grepl("^[0-9]+\\s*[Gg]$", mem_str)) {
      cli::cli_abort(c(
        "x Invalid {.code --h2o-mem} value: {.val {mem_str}}.",
        "i Please specify memory with a {.emph 'G'} suffix, e.g. {.code 8G}, {.code 16G}, {.code 32G}."
      ))
    }
    opt$`h2o-mem` <- gsub("\\s+", "", toupper(mem_str)) # normalize
  }

  # Round message (no normalization here — use the parsed integer/NA as-is)
  round_msg <- if (isTRUE(is.na(opt$round))) {
    "None"
  } else if (opt$round == 0L) {
    "0 decimals"
  } else if (opt$round == 1L) {
    "1 decimal place"
  } else {
    sprintf("%d decimal places", opt$round)
  }

  # Header
  .line <- if (isTRUE(l10n_info()[["UTF-8"]])) "─" else "-"
  hdr <- cli::rule(left = cli::col_cyan(cli::style_bold("imputeflow")), line = .line, col = "cyan")
  cat(hdr, "\n", file = stderr(), sep = "")
  cli::cli_alert_info("Method               : {.method Distributed Random Forest (DRF)}")
  cli::cli_alert_info("Round                : {.round {round_msg}}")
  cli::cli_alert_info("Number of Trees      : {.ntrees {opt$ntrees}}")
  cli::cli_alert_info("Max Depth            : {.mdepth {opt$`max-depth`}}")
  cli::cli_alert_info("Sample Rate          : {.srate {opt$`sample-rate`}}")
  cli::cli_alert_info("Sample Rate Per Tree : {.treer {opt$`col-sample-rate-per-tree`}}")
  cli::cli_alert_info("Mode                 : {.mode fit-apply}")
  cli::cli_alert_info("H2O Memory           : {.mem {if (is.null(opt$`h2o-mem`) || !nzchar(opt$`h2o-mem`)) 'auto' else opt$`h2o-mem`}}")
  cli::cli_alert_info("Requested Threads    : {.num {if (is.na(opt$`h2o-threads`)) 'auto' else opt$`h2o-threads`}}")

  # Inputs
  df   <- read_stdin_csv(verbose = !opt$quiet)
  cols <- parse_cols(opt$cols)
  excl <- parse_cols(opt$`exclude-predictors`)

  shown <- if (!is.null(cols)) cols else names(df)
  short <- if (length(shown) > 3L) paste0(paste(shown[1:3], collapse = ", "), ", ...") else paste(shown, collapse = ", ")
  cli::cli_alert_info("Columns              : {.columns {short}} ({.num {length(shown)}} total)")

  # Resolve train rows and show friendly split (train % from --train-frac when provided)
  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )
  n_total  <- nrow(df)
  n_train  <- length(train_rows)

  if (is.null(opt$`train-rows`) && is.null(opt$`train-mask`) &&
      is.numeric(opt$`train-frac`) && is.finite(opt$`train-frac`) &&
      opt$`train-frac` > 0 && opt$`train-frac` <= 1) {
    pct_train <- round(100 * opt$`train-frac`, 1)
  } else {
    pct_train <- round(100 * (n_train / max(n_total, 1L)), 1)
  }
  n_test <- max(n_total - n_train, 0L)
  pct_test <- round(100 - pct_train, 1)

  cli::cli_alert_info("Training rows        : {.num {n_train}} / {.num {n_total}} ({.num {pct_train}}%)")
  cli::cli_alert_info("Holdout (test)       : {.num {n_test}} / {.num {n_total}} ({.num {pct_test}}%)")

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(target_cols, function(nm) imputeflow:::needs_imputation(df[[nm]]), logical(1))]

  # Redirect base output to stderr during modeling; restore before CSV write
  state <- redirect_start()
  did_redirect_stop <- FALSE
  on.exit(if (!did_redirect_stop) redirect_stop(state), add = TRUE)

  # H2O start that RESPECTS --h2o-mem / --h2o-threads even if a cluster exists
  h2o_start_with_knobs <- function(h2o_mem, h2o_threads, quiet = TRUE) {
    if (!requireNamespace("h2o", quietly = TRUE)) {
      stop("Package 'h2o' is required. Install it first.", call. = FALSE)
    }
    nthreads_final <- if (!is.null(h2o_threads) && !is.na(h2o_threads)) as.integer(h2o_threads) else -1L
    mem_final      <- if (!is.null(h2o_mem) && nzchar(h2o_mem)) h2o_mem else NULL

    existing <- try(h2o::h2o.getConnection(), silent = TRUE)
    need_restart <- inherits(existing, "H2OConnection") && (!is.null(mem_final) || !is.null(h2o_threads))

    if (need_restart) {
      suppressWarnings(try(h2o::h2o.shutdown(prompt = FALSE), silent = TRUE))
      for (i in seq_len(120L)) {
        Sys.sleep(0.25)
        probe <- try(h2o::h2o.getConnection(), silent = TRUE)
        if (inherits(probe, "try-error") || !inherits(probe, "H2OConnection")) break
      }
    }

    if (is.null(mem_final)) {
      conn <- h2o::h2o.init(nthreads = nthreads_final)
    } else {
      conn <- h2o::h2o.init(max_mem_size = mem_final, nthreads = nthreads_final)
    }
    if (quiet) try(h2o::h2o.no_progress(), silent = TRUE)
    invisible(conn)
  }

  h2o_conn <- h2o_start_with_knobs(
    h2o_mem     = opt$`h2o-mem`,
    h2o_threads = if (!is.na(opt$`h2o-threads`)) opt$`h2o-threads` else NULL,
    quiet       = !opt$quiet
  )

  # === Progress bar ==========================================================
  total_cols <- max(length(eligible), 1L)
  pb <- cli::cli_progress_bar("Imputing (DRF)", total = total_cols)
  cli::cli_progress_update(id = pb, set = 0)

  # Timer for MODEL RUN ONLY (fit/apply)
  t_model_start <- Sys.time()

  hook <- if (length(eligible)) {
    function() cli::cli_progress_update(id = pb)
  } else {
    NULL
  }

  out <- imputeflow::impute_h2o_drf_fit_apply(
    df,
    cols                     = eligible,
    exclude_predictors       = excl,
    train_rows               = train_rows,
    ntrees                   = opt$ntrees,
    max_depth                = opt$`max-depth`,
    min_rows                 = opt$`min-rows`,
    sample_rate              = opt$`sample-rate`,
    col_sample_rate_per_tree = opt$`col-sample-rate-per-tree`,
    balance_classes          = opt$`balance-classes`,
    seed                     = opt$seed,
    round_digits             = opt$round,   # 0 = integer rounding; NA = no rounding
    h2o_threads              = if (!is.na(opt$`h2o-threads`)) opt$`h2o-threads` else NULL,
    h2o_mem                  = opt$`h2o-mem`,
    verbose                  = FALSE,
    progress_hook            = hook,
    h2o_connection           = h2o_conn
  )

  if (!length(eligible)) cli::cli_progress_update(id = pb)
  cli::cli_progress_done(id = pb)

  # Compute/print model duration
  dt_secs <- as.numeric(difftime(Sys.time(), t_model_start, units = "secs"))
  if (dt_secs < 60) {
    cli::cli_alert_success("Completed DRF in {.num {round(dt_secs, 1)}}s.")
  } else {
    mins <- floor(dt_secs / 60)
    secs <- round(dt_secs %% 60)
    cli::cli_alert_success("Completed DRF in {.num {mins}}m {.num {secs}}s.")
  }

  # Restore stdout BEFORE writing CSV so redirection works
  if (!did_redirect_stop) {
    redirect_stop(state)
    did_redirect_stop <- TRUE
  }
  write_stdout_csv(out, verbose = !opt$quiet)

  if (isTRUE(opt$`h2o-shutdown`)) {
    tryCatch(h2o::h2o.shutdown(prompt = TRUE), error = function(e) NULL)
  }
}

dispatch <- list()
if (exists("run_mean",   mode = "function")) dispatch$mean   <- run_mean
if (exists("run_median", mode = "function")) dispatch$median <- run_median
if (exists("run_mode",   mode = "function")) dispatch$mode   <- run_mode
if (exists("run_knn",    mode = "function")) dispatch$knn    <- run_knn
if (exists("run_drf",    mode = "function")) dispatch$drf    <- run_drf

if (method %in% names(dispatch)) {
  dispatch[[method]]()
} else {
  cli::cli_alert_danger("Unknown or unavailable method: {method}")
  quit(status = 2)
}