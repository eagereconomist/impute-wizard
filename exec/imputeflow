#!/usr/bin/env Rscript

suppressPackageStartupMessages({
  library(optparse)
  library(cli)
  library(imputeflow)
})

# make progress bars show immediately
options(cli.progress_show_after = 0, cli.progress_clear = FALSE)

argv <- commandArgs(trailingOnly = TRUE)

if (length(argv) == 0 || argv[1] %in% c("-h", "--help")) {
  cat("
Usage: imputeflow <method> [options]

Methods:
  mean       Impute using column-wise mean
  median     Impute using column-wise median
  mode       Impute using column-wise mode
  knn        Impute using k-Nearest Neighbors
  drf        Impute using Distributed Random Forest (H2O)

Use --help with a method to see its options, e.g.:
  imputeflow mean --help
")
  quit(status = if (length(argv) == 0) 2 else 0)
}

method <- tolower(argv[1])
args   <- argv[-1]

# Parse a comma-separated list of column names
# @keywords internal
# @noRd
parse_cols <- function(x) {
  if (is.null(x) || is.na(x) || !nzchar(x)) return(NULL)
  cols <- strsplit(x, ",", fixed = TRUE)[[1]]
  cols <- trimws(cols)
  cols <- cols[nzchar(cols)]
  unique(cols)
}

# Read CSV from stdin
# @keywords internal
# @noRd
read_stdin_csv <- function(verbose = FALSE, spinner = NULL) {
  if (!requireNamespace("readr", quietly = TRUE)) {
    stop("Package 'readr' is required for CLI IO. Install it first.", call. = FALSE)
  }
  df <- readr::read_csv(file("stdin"), show_col_types = FALSE)

  if (is.function(df)) {
    cli::cli_abort(c(
      "x Internal error: read_stdin_csv() received a function, not data.",
      "i Did you accidentally write {.code df <- readr::read_csv} without parentheses?",
      "i It must be {.code df <- readr::read_csv(file('stdin'), show_col_types = FALSE)}"
    ))
  }

  as.data.frame(df, stringsAsFactors = FALSE)
}

# Write CSV to stdout
# @keywords internal
# @noRd
write_stdout_csv <- function(df, verbose = FALSE, spinner = NULL) {
  if (!requireNamespace("readr", quietly = TRUE)) {
    stop("Package 'readr' is required for CLI IO. Install it first.", call. = FALSE)
  }
  readr::write_csv(df, stdout())
  invisible(df)
}

# Common CLI options for fit/apply style commands
# @keywords internal
# @noRd
common_fit_apply_opts <- function() {
  list(
    make_option(c("--mode"), type = "character", default = "fit-apply",
                help = "One of: fit, apply, fit-apply (default)"),
    make_option(c("--save-spec"), type = "character", default = NULL,
                help = "Path to save the fitted imputer spec (fit or fit-apply)"),
    make_option(c("--load-spec"), type = "character", default = NULL,
                help = "Path to load an existing imputer spec (apply)"),
    make_option(c("-c", "--cols"), type = "character", default = NULL,
                help = "Comma-separated columns to impute (default: auto/all)"),
    make_option(c("--exclude-predictors"), type = "character", default = NULL,
                help = "Comma-separated predictor columns to EXCLUDE (kNN/DRF)"),
    make_option(c("--train-frac"), type = "double", default = 1.0,
                help = "Fraction of rows to use as training (0-1] if no train rows/mask"),
    make_option(c("--train-rows"), type = "character", default = NULL,
                help = "Path to newline-separated 1-based row indices for training"),
    make_option(c("--train-mask"), type = "character", default = NULL,
                help = "Path to CSV containing a boolean mask column for training rows"),
    make_option(c("--mask-col"), type = "character", default = NULL,
                help = "Column name in --train-mask to use (default: first logical)"),
    make_option(c("--seed"), type = "integer", default = 1),
    make_option(c("--round"), type = "integer", default = NA,
                help = "Digits for final rounding (post-processing). Omit for no rounding."),
    make_option(c("--quiet"), action = "store_true", default = FALSE)
  )
}

# Print a compact “columns” banner to CLI
# @keywords internal
# @noRd
.print_cols_banner <- function(df, cols) {
  target_cols <- if (!is.null(cols)) cols else names(df)
  if (!is.null(cols)) {
    max_cols <- 3
    if (length(cols) > max_cols) {
      short_cols <- paste(c(cols[1:max_cols], "..."), collapse = ", ")
      cli::cli_alert_info("Columns      : {short_cols} ({length(cols)} total)")
    } else {
      cli::cli_alert_info("Columns      : {paste(cols, collapse = ', ')}")
    }
  } else {
    cli::cli_alert_info("Columns        : All Columns ({length(target_cols)} total)")
  }
}

# Begin redirecting base R stdout/messages to terminal stderr
# @keywords internal
# @noRd
redirect_start <- function() {
  old_out <- sink.number()
  old_msg <- sink.number(type = "message")
  sink(stderr())
  sink(stderr(), type = "message")
  list(old_out = old_out, old_msg = old_msg)
}

# Stop redirecting and restore previous sinks
# @keywords internal
# @noRd
redirect_stop <- function(state) {
  while (sink.number(type = "message") > state$old_msg) {
    try(sink(type = "message"), silent = TRUE)
  }
  while (sink.number() > state$old_out) {
    try(sink(), silent = TRUE)
  }
}

# small helper to print the same arrowed per-column line as DRF
.per_col_line <- function(colname) {
  sym <- cli::symbol
  cat(
    paste0(
      cli::col_silver(sym$arrow_right, " "),
      cli::col_silver("imputing column : "),
      cli::col_cyan(colname),
      "\n"
    ),
    file = stderr()
  )
  flush.console()
}

# Run the mean CLI subcommand (with progress bar)
# @keywords internal
# @noRd
run_mean <- function() {
  option_list <- c(common_fit_apply_opts())
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  cli::cli_h1("imputeflow")
  cli::cli_alert_info("Method  : MEAN")
  cli::cli_alert_info("Mode    : {opt$mode} | Training fraction (fallback): {opt$`train-frac`}")

  df   <- read_stdin_csv(verbose = !opt$quiet)
  cols <- parse_cols(opt$cols)
  .print_cols_banner(df, cols)

  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(
    target_cols,
    function(nm) is.numeric(df[[nm]]) && imputeflow:::needs_imputation(df[[nm]]),
    logical(1)
  )]
  mode  <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  t0 <- Sys.time()
  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    spec <- imputeflow::fit_mean_spec(df, cols = eligible, train_rows = train_rows)
    # visual-only progress for fitting
    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Fitting mean spec", total = length(spec$cols))
      for (nm in spec$cols) cli::cli_progress_update(id = bar_id)
      cli::cli_progress_done(id = bar_id)
    }
    saveRDS(spec, opt$`save-spec`)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")
    invisible(NULL)
  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    spec <- readRDS(opt$`load-spec`)
    out_full <- imputeflow::apply_mean_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        if (!nm %in% names(out)) { cli::cli_progress_update(id = bar_id); next }
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    write_stdout_csv(out, verbose = !opt$quiet)
  } else {
    spec <- imputeflow::fit_mean_spec(df, cols = eligible, train_rows = train_rows)
    out_full <- imputeflow::apply_mean_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    if (!is.null(opt$`save-spec`)) {
      saveRDS(spec, opt$`save-spec`)
      cli::cli_alert_info("Saved spec to {opt$`save-spec`}.")
    }
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  dt <- round(difftime(Sys.time(), t0, units = "secs"), 2)
  cli::cli_alert_success("Completed mean in {dt} seconds.")
}

# Run the median CLI subcommand (with progress bar)
# @keywords internal
# @noRd
run_median <- function() {
  option_list <- c(common_fit_apply_opts())
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  df <- read_stdin_csv(verbose = !opt$quiet)
  cli::cli_h1("imputeflow")
  cli::cli_alert_info("Method  : MEDIAN")
  cli::cli_alert_info("Mode    : {opt$mode} | Training fraction (fallback): {opt$`train-frac`}")

  cols <- parse_cols(opt$cols)
  .print_cols_banner(df, cols)

  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(
    target_cols,
    function(nm) is.numeric(df[[nm]]) && imputeflow:::needs_imputation(df[[nm]]),
    logical(1)
  )]
  mode  <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  t0 <- Sys.time()
  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    spec <- imputeflow::fit_median_spec(df, cols = eligible, train_rows = train_rows)
    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Fitting median spec", total = length(spec$cols))
      for (nm in spec$cols) cli::cli_progress_update(id = bar_id)
      cli::cli_progress_done(id = bar_id)
    }
    saveRDS(spec, opt$`save-spec`)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")
  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    spec <- readRDS(opt$`load-spec`)
    out_full <- imputeflow::apply_median_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEDIAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        if (!nm %in% names(out)) { cli::cli_progress_update(id = bar_id); next }
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    write_stdout_csv(out, verbose = !opt$quiet)
  } else {
    spec <- imputeflow::fit_median_spec(df, cols = eligible, train_rows = train_rows)
    out_full <- imputeflow::apply_median_spec(df, spec, round_digits = opt$round)

    if (length(spec$cols)) {
      bar_id <- cli::cli_progress_bar("Imputing (MEDIAN)", total = length(spec$cols))
      out <- df
      for (nm in spec$cols) {
        .per_col_line(nm)
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = bar_id)
      }
      cli::cli_progress_done(id = bar_id)
    } else {
      out <- out_full
    }

    if (!is.null(opt$`save-spec`)) {
      saveRDS(spec, opt$`save-spec`)
      cli::cli_alert_info("Saved spec to {opt$`save-spec`}.")
    }
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  dt <- round(difftime(Sys.time(), t0, units = "secs"), 2)
  cli::cli_alert_success("Completed median in {dt} seconds.")
}

# Run the knn CLI subcommand (styled theme + splits + timer)
# @keywords internal
# @noRd
run_knn <- function() {
  option_list <- c(
    common_fit_apply_opts(),
    make_option(c("--neighbors"), type = "integer", default = 5,
                help = "Number of neighbors (k) for recipes::step_impute_knn")
  )
  opt <- parse_args(OptionParser(option_list = option_list), args = args)

  # Guards
  if (is.na(opt$neighbors) || opt$neighbors < 1L) {
    cli::cli_abort("x {.code --neighbors} must be a positive integer.")
  }

  # Progress/CLI output to stderr; keep stdout clean for CSV
  old_opts <- options(
    cli.progress_show_after = 0,
    cli.progress_clear      = FALSE,
    cli.progress_output     = "stderr",
    cli.num_colors          = 256,
    crayon.enabled          = TRUE,
    readr.show_progress     = FALSE
  )
  on.exit(options(old_opts), add = TRUE)

  # ── Theme (vivid|minimal) + GREEN progress bar ────────────────────────────
  style <- tolower(Sys.getenv("IMPUTEFLOW_STYLE", "vivid"))
  theme <- switch(
    style,
    minimal = list(
      ".impute .label"   = list(),
      ".impute .val"     = list("font-weight" = "bold"),
      ".impute .method"  = list(bold = TRUE),
      ".impute .mode"    = list(bold = TRUE, color = "blue"),
      ".impute .columns" = list(bold = TRUE),
      ".impute .col"     = list(bold = TRUE),
      ".impute .num"     = list(color = "blue"),
      ".impute .mem"     = list(color = "magenta"),
      # split styles to match DRF
      ".impute .train"   = list(color = "green",  "font-weight" = "bold"),
      ".impute .valset"  = list(color = "yellow", "font-weight" = "bold"),
      ".impute .testset" = list(color = "cyan",   "font-weight" = "bold"),
      # progress bar styling (green)
      ".progress-bar .bar"          = list(color = "green"),
      ".progress-bar .bar-complete" = list(color = "green"),
      ".progress-bar .current"      = list(color = "green")
    ),
    # vivid (default)
    list(
      ".impute h1"       = list(color = "#6A5ACD", "font-weight" = "bold"),
      ".impute .label"   = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .val"     = list(color = "#F8F8FF", "font-weight" = "bold"),
      ".impute .method"  = list(color = "#FF69B4", "font-weight" = "bold"),
      ".impute .mode"    = list(color = "#7FFFD4",   "font-weight" = "bold"),
      ".impute .round"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .columns" = list(color = "#F8F8FF"),
      ".impute .col"     = list(color = "#FFD700", "font-weight" = "bold"),
      ".impute .num"     = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .ok"      = list(color = "#32CD32"),
      ".impute .warn"    = list(color = "#FFA07A"),
      # split styles
      ".impute .train"   = list(color = "#32CD32", "font-weight" = "bold"),
      ".impute .valset"  = list(color = "#FFD700", "font-weight" = "bold"),
      ".impute .testset" = list(color = "#87CEEB", "font-weight" = "bold"),
      # progress bar styling (green)
      ".progress-bar .bar"          = list(color = "#32CD32"),
      ".progress-bar .bar-complete" = list(color = "#32CD32"),
      ".progress-bar .current"      = list(color = "#32CD32")
    )
  )
  div_id <- cli::cli_div(class = "impute", theme = theme)
  on.exit(cli::cli_end(div_id), add = TRUE)

  # Helpers
  pct_str <- function(x) sprintf("%.2f%%", round(x * 100, 2))
  fmtn    <- function(x) format(x, big.mark = ",", scientific = FALSE, trim = TRUE)

  # Round message (like DRF)
  round_msg <- if (isTRUE(is.na(opt$round))) {
    "None"
  } else if (opt$round == 0L) {
    "0 decimals"
  } else if (opt$round == 1L) {
    "1 decimal place"
  } else {
    sprintf("%d decimal places", opt$round)
  }

  # Header
  .line <- if (isTRUE(l10n_info()[["UTF-8"]])) "─" else "-"
  hdr <- cli::rule(left = cli::col_cyan(cli::style_bold("imputeflow")), line = .line, col = "cyan")
  cat(hdr, "\n", file = stderr(), sep = "")
  cli::cli_alert_info("Method               : {.method k-Nearest Neighbors (kNN)}")
  cli::cli_alert_info("Round                : {.round {round_msg}}")
  cli::cli_alert_info("Neighbors (k)        : {.num {opt$neighbors}}")
  cli::cli_alert_info("Mode                 : {.mode {opt$mode}}")

  # Inputs
  df   <- read_stdin_csv(verbose = !opt$quiet)
  n    <- nrow(df)
  cols <- parse_cols(opt$cols)
  excl <- parse_cols(opt$`exclude-predictors`)

  shown <- if (!is.null(cols)) cols else names(df)
  short <- if (length(shown) > 3L) paste0(paste(shown[1:3], collapse = ", "), ", ...") else paste(shown, collapse = ", ")
  cli::cli_alert_info("Columns              : {.columns {short}} ({.num {length(shown)}} total)")

  # Resolve training rows (from file/mask/fraction)
  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )
  cli::cli_alert_info(
    "Training rows        : {.num {fmtn(length(train_rows))}} / {.num {fmtn(n)}} ({.train {pct_str(length(train_rows)/n)}})"
  )

  # If mask CSV present, show Validation/Test; else, notional Test = n - train
  if (!is.null(opt$`train-mask`) && nzchar(opt$`train-mask`) && file.exists(opt$`train-mask`)) {
    mask_try <- try(suppressWarnings(readr::read_csv(opt$`train-mask`, show_col_types = FALSE)), silent = TRUE)
    if (!inherits(mask_try, "try-error")) {
      mdf <- as.data.frame(mask_try, stringsAsFactors = FALSE)
      to_bool <- function(v) {
        if (is.logical(v)) v
        else if (is.numeric(v)) v != 0
        else if (is.character(v)) tolower(trimws(v)) %in% c("true","t","1","yes","y")
        else rep(FALSE, length(v))
      }
      val_n  <- if ("is_val"  %in% names(mdf)) sum(to_bool(mdf[["is_val"]]),  na.rm = TRUE) else NA_integer_
      test_n <- if ("is_test" %in% names(mdf)) sum(to_bool(mdf[["is_test"]]), na.rm = TRUE) else NA_integer_
      if (is.na(val_n) && is.na(test_n) && "split_id" %in% names(mdf) && is.numeric(mdf[["split_id"]])) {
        sid <- mdf[["split_id"]]
        val_n  <- sum(sid == 2, na.rm = TRUE)
        test_n <- sum(sid == 3, na.rm = TRUE)
      }
      if (!is.na(val_n))  cli::cli_alert_info("Validation rows       : {.num {fmtn(val_n)}} / {.num {fmtn(n)}} ({.valset {pct_str(val_n/n)}})")
      if (!is.na(test_n)) cli::cli_alert_info("Test rows             : {.num {fmtn(test_n)}} / {.num {fmtn(n)}} ({.testset {pct_str(test_n/n)}})")
      if (is.na(test_n)) {
        t2 <- n - length(train_rows)
        if (t2 >= 0) cli::cli_alert_info("Test rows             : {.num {fmtn(t2)}} / {.num {fmtn(n)}} ({.testset {pct_str(t2/n)}})")
      }
    }
  } else {
    t2 <- n - length(train_rows)
    if (t2 >= 0) cli::cli_alert_info("Test rows            : {.num {fmtn(t2)}} / {.num {fmtn(n)}} ({.testset {pct_str(t2/n)}})")
  }

  # NA-safe ID-like predictor warning (AFTER splits)
  {
    candidates <- setdiff(names(df), excl %||% character(0))
    is_id_like <- function(nm, x) {
      nm_lc <- tolower(nm)
      has_id_word <- grepl("\\b(id|uuid|guid)\\b", nm_lc)

      nn  <- sum(!is.na(x))
      u   <- length(unique(x[!is.na(x)]))
      rat <- if (nn > 0) u / nn else 0
      high_card <- (u >= 1000) || (rat >= 0.95)

      is_charfac <- is.character(x) || is.factor(x)
      is_integery <- is.numeric(x) && {
        fx <- x[is.finite(x)]
        length(fx) > 0 && all(abs(fx - round(fx)) < .Machine$double.eps^0.5)
      }

      (has_id_word && (is_charfac || is_integery)) || high_card
    }

    id_hits <- character(0)
    for (nm in candidates) {
      x <- df[[nm]]
      # Skip obvious numeric continuous columns (NA-safe)
      if (is.numeric(x)) {
        fx <- x[is.finite(x)]
        intish <- length(fx) > 0 && all(abs(fx - round(fx)) < .Machine$double.eps^0.5)
        if (!intish) next
      }
      if (is_id_like(nm, x)) id_hits <- c(id_hits, nm)
    }
    id_hits <- setdiff(unique(id_hits), excl %||% character(0))
    if (length(id_hits)) {
      pretty <- paste(sprintf("`%s`", id_hits), collapse = ", ")
      cli::cli_alert_warning(
        "Detected ID-like predictors: {pretty}. These can distort kNN distances and slow imputation. Consider excluding via {.code --exclude-predictors}."
      )
    }
  }

  # Determine eligible numeric targets with missingness
  numeric_cols <- names(df)[vapply(df, is.numeric, logical(1))]
  if (!is.null(cols)) numeric_cols <- intersect(numeric_cols, cols)
  eligible <- numeric_cols[vapply(df[numeric_cols], function(x) any(is.na(x)), logical(1))]

  # Mode (fit/apply/fit-apply)
  mode <- match.arg(tolower(opt$mode), c("fit", "apply", "fit-apply"))

  # Timer for MODEL RUN ONLY (fit/apply)
  t_model_start <- Sys.time()

  if (mode == "fit") {
    if (is.null(opt$`save-spec`)) cli::cli_abort("--save-spec is required in 'fit' mode.")
    pb <- cli::cli_progress_bar("Fitting (kNN)", total = 1)
    spec <- imputeflow::fit_knn_spec(
      df, cols = eligible, neighbors = opt$neighbors, train_rows = train_rows,
      exclude_predictors = excl
    )
    cli::cli_progress_update(id = pb)
    cli::cli_progress_done(id = pb)
    saveRDS(spec, opt$`save-spec`)
    cli::cli_alert_success("Saved spec to {opt$`save-spec`}.")

  } else if (mode == "apply") {
    if (is.null(opt$`load-spec`)) cli::cli_abort("--load-spec is required in 'apply' mode.")
    spec <- readRDS(opt$`load-spec`)
    pb   <- cli::cli_progress_bar("Imputing (kNN)", total = max(length(spec$cols), 1L))
    out_full <- imputeflow::apply_knn_spec(df, spec, round_digits = opt$round)
    out <- df
    if (length(spec$cols)) {
      for (nm in spec$cols) {
        if (!nm %in% names(out)) { cli::cli_progress_update(id = pb); next }
        out[[nm]] <- out_full[[nm]]
        cli::cli_progress_update(id = pb)
      }
    } else {
      cli::cli_progress_update(id = pb)
    }
    cli::cli_progress_done(id = pb)
    write_stdout_csv(out, verbose = !opt$quiet)

  } else { # fit-apply
    n_cols <- length(eligible)
    pb <- cli::cli_progress_bar("Imputing (kNN)", total = max(n_cols, 1L))
    out <- df

    if (n_cols == 0L) {
      cli::cli_progress_update(id = pb)
      cli::cli_progress_done(id = pb)
      write_stdout_csv(out, verbose = !opt$quiet)
      # timer + return
      dt_secs <- as.numeric(difftime(Sys.time(), t_model_start, units = "secs"))
      if (dt_secs < 60) {
        cli::cli_alert_success("Completed kNN in {.num {round(dt_secs, 1)}}s.")
      } else {
        mins <- floor(dt_secs / 60); secs <- round(dt_secs %% 60)
        cli::cli_alert_success("Completed kNN in {.num {mins}}m {.num {secs}}s.")
      }
      return(invisible(NULL))
    }

    for (nm in eligible) {
      spec_one <- imputeflow::fit_knn_spec(
        out, cols = nm, neighbors = opt$neighbors, train_rows = train_rows,
        exclude_predictors = excl
      )
      out_one <- imputeflow::apply_knn_spec(out, spec_one, round_digits = opt$round)
      if (nm %in% names(out_one)) out[[nm]] <- out_one[[nm]]
      cli::cli_progress_update(id = pb)
    }
    cli::cli_progress_done(id = pb)
    write_stdout_csv(out, verbose = !opt$quiet)
  }

  # Model duration (pretty like DRF)
  dt_secs <- as.numeric(difftime(Sys.time(), t_model_start, units = "secs"))
  if (dt_secs < 60) {
    cli::cli_alert_success("Completed kNN in {.num {round(dt_secs, 1)}}s.")
  } else {
    mins <- floor(dt_secs / 60); secs <- round(dt_secs %% 60)
    cli::cli_alert_success("Completed kNN in {.num {mins}}m {.num {secs}}s.")
  }
}

#' Run the drf CLI subcommand (styled theme + single GREEN bar + timer)
#' @keywords internal
#' @noRd
run_drf <- function() {
  # Collect argv and strip any leading subcommand tokens like "drf" or "impute drf"
  get_argv <- function() {
    if (exists("args", inherits = FALSE)) args else commandArgs(trailingOnly = TRUE)
  }
  argv <- get_argv()
  while (length(argv) && argv[1L] %in% c("impute", "drf")) {
    argv <- argv[-1L]
  }

  option_list <- c(
    common_fit_apply_opts(),
    make_option(c("--ntrees"), type = "integer", default = 50),
    make_option(c("--max-depth"), type = "integer", default = 10),
    make_option(c("--min-rows"), type = "integer", default = 5),
    make_option(c("--sample-rate"), type = "double", default = 0.8),
    make_option(c("--col-sample-rate-per-tree"), type = "double", default = 0.8),
    make_option(c("--balance-classes"), action = "store_true", default = FALSE),

    # NEW: CV controls (wired end-to-end)
    make_option(
      c("--nfolds"), type = "integer", default = 0,
      help = "Number of CV folds (0 disables CV). Must be 0 or \u2265 2; H2O disallows 1."
    ),
    make_option(
      c("--fold-assignment"), type = "character", default = "AUTO",
      help = "Fold assignment when nfolds > 0: AUTO|Random|Modulo|Stratified|SPC"
    ),

    make_option(c("--h2o-threads"), type = "integer", default = NA_integer_),
    make_option(c("--h2o-mem"), type = "character", default = NULL),
    make_option(
      c("--fallback"), type = "character", default = "none",
      help = "Fallback if DRF doesn't reduce missingness: none|mean|median|mode"
    ),
    make_option(c("--h2o-shutdown"), action = "store_true", default = FALSE)
  )
  opt <- parse_args(OptionParser(option_list = option_list), args = argv)

  if (!is.null(opt$`save-spec`) || !is.null(opt$`load-spec`) || tolower(opt$mode) != "fit-apply") {
    cli::cli_abort(c(
      "x DRF currently supports only {.code --mode fit-apply} in a single session.",
      "i Spec save/load for DRF is not yet supported."
    ))
  }

  # Guard: --nfolds must be 0 or >= 2
  if (!is.null(opt$nfolds) && is.finite(opt$nfolds) && as.integer(opt$nfolds) == 1L) {
    cli::cli_abort(c(
      "x Invalid {.code --nfolds 1}. H2O requires 0 or \u2265 2.",
      "i Set {.code --nfolds 0} to disable CV, or pick \u2265 2."
    ))
  }

  # Guard: --h2o-mem must include a G suffix (e.g. 8G). If provided and invalid, abort early.
  if (!is.null(opt$`h2o-mem`) && nzchar(opt$`h2o-mem`)) {
    mem_str <- trimws(opt$`h2o-mem`)
    if (!grepl("^[0-9]+\\s*[Gg]$", mem_str)) {
      cli::cli_abort(c(
        "x Invalid {.code --h2o-mem} value: {.val {mem_str}}.",
        "i Please specify memory with a {.emph 'G'} suffix, e.g. {.code 8G}, {.code 16G}, {.code 32G}."
      ))
    }
    opt$`h2o-mem` <- gsub("\\s+", "", toupper(mem_str)) # normalize for display/consistency
  }

  # Progress: show immediately on stderr; keep stdout clean; silence readr bars
  old_opts <- options(
    cli.progress_show_after = 0,
    cli.progress_clear      = FALSE,
    cli.progress_output     = "stderr",
    cli.num_colors          = 256,
    crayon.enabled          = TRUE,
    readr.show_progress     = FALSE
  )
  on.exit(options(old_opts), add = TRUE)

  # ── Theme (vivid|minimal) + GREEN progress bar ────────────────────────────
  style <- tolower(Sys.getenv("IMPUTEFLOW_STYLE", "vivid"))
  theme <- switch(
    style,
    minimal = list(
      ".impute .label"   = list(),
      ".impute .val"     = list("font-weight" = "bold"),
      ".impute .method"  = list(bold = TRUE),
      ".impute .mode"    = list(bold = TRUE, color = "blue"),
      ".impute .columns" = list(bold = TRUE),
      ".impute .col"     = list(bold = TRUE),
      ".impute .num"     = list(color = "blue"),
      ".impute .mem"     = list(color = "magenta"),
      ".impute .train"   = list(color = "green",  "font-weight" = "bold"),
      ".impute .valset"  = list(color = "yellow", "font-weight" = "bold"),
      ".impute .testset" = list(color = "cyan",   "font-weight" = "bold"),
      ".progress-bar .bar"          = list(color = "green"),
      ".progress-bar .bar-complete" = list(color = "green"),
      ".progress-bar .current"      = list(color = "green")
    ),
    list(
      ".impute h1"       = list(color = "#6A5ACD", "font-weight" = "bold"),
      ".impute .label"   = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .val"     = list(color = "#F8F8FF", "font-weight" = "bold"),
      ".impute .method"  = list(color = "#FF69B4", "font-weight" = "bold"),
      ".impute .round"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .ntrees"  = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .mdepth"  = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .srate"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .treer"   = list(color = "#87CEEB", "font-weight" = "bold"),
      ".impute .mode"    = list(color = "#7FFFD4", "font-weight" = "bold"),
      ".impute .columns" = list(color = "#F8F8FF"),
      ".impute .col"     = list(color = "#FFD700", "font-weight" = "bold"),
      ".impute .num"     = list(color = "#20B2AA", "font-weight" = "bold"),
      ".impute .mem"     = list(color = "#9370DB", "font-weight" = "bold"),
      ".impute .ok"      = list(color = "#32CD32"),
      ".impute .warn"    = list(color = "#FFA07A"),
      ".impute .train"   = list(color = "#32CD32", "font-weight" = "bold"),
      ".impute .valset"  = list(color = "#FFD700", "font-weight" = "bold"),
      ".impute .testset" = list(color = "#87CEEB", "font-weight" = "bold"),
      ".progress-bar .bar"          = list(color = "#32CD32"),
      ".progress-bar .bar-complete" = list(color = "#32CD32"),
      ".progress-bar .current"      = list(color = "#32CD32")
    )
  )
  div_id <- cli::cli_div(class = "impute", theme = theme)
  on.exit(cli::cli_end(div_id), add = TRUE)

  # Helpers
  pct_str <- function(x) sprintf("%.2f%%", round(x * 100, 2))
  fmtn    <- function(x) format(x, big.mark = ",", scientific = FALSE, trim = TRUE)

  # Round message (no normalization here — use the parsed integer/NA as-is)
  round_msg <- if (isTRUE(is.na(opt$round))) {
    "None"
  } else if (opt$round == 0L) {
    "0 decimals"
  } else if (opt$round == 1L) {
    "1 decimal place"
  } else {
    sprintf("%d decimal places", opt$round)
  }

  # Header
  .line <- if (isTRUE(l10n_info()[["UTF-8"]])) "─" else "-"
  hdr <- cli::rule(left = cli::col_cyan(cli::style_bold("imputeflow")), line = .line, col = "cyan")
  cat(hdr, "\n", file = stderr(), sep = "")
  cli::cli_alert_info("Method                   : {.method Distributed Random Forest (DRF)}")
  cli::cli_alert_info("Round                    : {.round {round_msg}}")
  cli::cli_alert_info("Number of Trees          : {.ntrees {opt$ntrees}}")
  cli::cli_alert_info("Max Depth                : {.mdepth {opt$`max-depth`}}")
  cli::cli_alert_info("Sample Rate              : {.srate {opt$`sample-rate`}}")
  cli::cli_alert_info("Sample Rate Per Tree     : {.treer {opt$`col-sample-rate-per-tree`}}")
  cli::cli_alert_info("Mode                     : {.mode fit-apply}")
  cli::cli_alert_info("H2O Memory               : {.mem {if (is.null(opt$`h2o-mem`) || !nzchar(opt$`h2o-mem`)) 'auto' else opt$`h2o-mem`}}")
  cli::cli_alert_info("Requested Threads        : {.num {if (is.na(opt$`h2o-threads`)) 'auto' else opt$`h2o-threads`}}")

  # CV header (only when enabled)
  if (!is.null(opt$nfolds) && is.finite(opt$nfolds) && as.integer(opt$nfolds) > 0L) {
    fa <- opt$`fold-assignment` %||% "AUTO"
    cli::cli_alert_info('Cross-Validation         : {.num {as.integer(opt$nfolds)}} folds | fold assignment: "{fa}"')
  }

  # Inputs
  df   <- read_stdin_csv(verbose = !opt$quiet)
  n    <- nrow(df)
  cols <- parse_cols(opt$cols)
  excl <- parse_cols(opt$`exclude-predictors`)

  shown <- if (!is.null(cols)) cols else names(df)
  short <- if (length(shown) > 3L) paste0(paste(shown[1:3], collapse = ", "), ", ...") else paste(shown, collapse = ", ")
  cli::cli_alert_info("Columns                  : {.columns {short}} ({.num {length(shown)}} total)")

  # Resolve training rows (from file/mask/fraction)
  train_rows <- imputeflow:::resolve_train_rows(
    df, opt$`train-rows`, opt$`train-mask`, opt$`mask-col`,
    train_frac = opt$`train-frac`, seed = opt$seed
  )
  cli::cli_alert_info(
    "Training rows            : {.num {fmtn(length(train_rows))}} / {.num {fmtn(n)}} ({.train {pct_str(length(train_rows)/n)}})"
  )

  # If a mask CSV exists, try to show Validation/Test too; otherwise show notional Test = n - train
  if (!is.null(opt$`train-mask`) && nzchar(opt$`train-mask`) && file.exists(opt$`train-mask`)) {
    mask_try <- try(suppressWarnings(readr::read_csv(opt$`train-mask`, show_col_types = FALSE)), silent = TRUE)
    if (!inherits(mask_try, "try-error")) {
      mdf <- as.data.frame(mask_try, stringsAsFactors = FALSE)
      to_bool <- function(v) {
        if (is.logical(v)) v
        else if (is.numeric(v)) v != 0
        else if (is.character(v)) tolower(trimws(v)) %in% c("true","t","1","yes","y")
        else rep(FALSE, length(v))
      }
      val_n  <- if ("is_val"  %in% names(mdf)) sum(to_bool(mdf[["is_val"]]),  na.rm = TRUE) else NA_integer_
      test_n <- if ("is_test" %in% names(mdf)) sum(to_bool(mdf[["is_test"]]), na.rm = TRUE) else NA_integer_
      if (is.na(val_n) && is.na(test_n) && "split_id" %in% names(mdf) && is.numeric(mdf[["split_id"]])) {
        sid <- mdf[["split_id"]]
        val_n  <- sum(sid == 2, na.rm = TRUE)
        test_n <- sum(sid == 3, na.rm = TRUE)
      }
      if (!is.na(val_n))  cli::cli_alert_info("Validation rows          : {.num {fmtn(val_n)}} / {.num {fmtn(n)}} ({.valset {pct_str(val_n/n)}})")
      if (!is.na(test_n)) cli::cli_alert_info("Test rows                : {.num {fmtn(test_n)}} / {.num {fmtn(n)}} ({.testset {pct_str(test_n/n)}})")
      if (is.na(test_n)) {
        t2 <- n - length(train_rows)
        if (t2 >= 0) cli::cli_alert_info("Test rows                : {.num {fmtn(t2)}} / {.num {fmtn(n)}} ({.testset {pct_str(t2/n)}})")
      }
    }
  } else {
    t2 <- n - length(train_rows)
    if (t2 >= 0) cli::cli_alert_info("Test rows                : {.num {fmtn(t2)}} / {.num {fmtn(n)}} ({.testset {pct_str(t2/n)}})")
  }

  # NA-safe ID-like predictor warning (AFTER train/val/test info)
  {
    candidates <- setdiff(names(df), excl %||% character(0))
    is_id_like <- function(nm, x) {
      nm_lc <- tolower(nm)
      has_id_word <- grepl("\\b(id|uuid|guid)\\b", nm_lc)
      nn <- sum(!is.na(x))
      u  <- length(unique(x[!is.na(x)]))
      rat <- if (nn > 0) u / nn else 0
      high_card <- (u >= 1000) || (rat >= 0.95)
      is_charfac <- is.character(x) || is.factor(x)
      is_integery <- is.numeric(x) && {
        fx <- x[is.finite(x)]
        length(fx) > 0 && all(abs(fx - round(fx)) < .Machine$double.eps^0.5)
      }
      (has_id_word && (is_charfac || is_integery)) || high_card
    }
    id_hits <- character(0)
    for (nm in candidates) {
      x <- df[[nm]]
      if (is.numeric(x)) {
        fx <- x[is.finite(x)]
        intish <- length(fx) > 0 && all(abs(fx - round(fx)) < .Machine$double.eps^0.5)
        if (!intish) next
      }
      if (is_id_like(nm, x)) id_hits <- c(id_hits, nm)
    }
    id_hits <- setdiff(unique(id_hits), excl %||% character(0))
    if (length(id_hits)) {
      pretty <- paste(sprintf("`%s`", id_hits), collapse = ", ")
      cli::cli_alert_warning(
        "Detected ID-like columns : {pretty}. These can slow DRF and cause 'levels not trained on' warnings. Consider excluding via {.code --exclude-predictors}."
      )
    }
  }

  target_cols <- if (!is.null(cols)) cols else names(df)
  eligible <- target_cols[vapply(target_cols, function(nm) imputeflow:::needs_imputation(df[[nm]]), logical(1))]

  # Redirect base output to stderr during modeling; restore before CSV write
  state <- redirect_start()
  did_redirect_stop <- FALSE
  on.exit(if (!did_redirect_stop) redirect_stop(state), add = TRUE)

  # H2O start that RESPECTS --h2o-mem / --h2o-threads even if a cluster exists
  h2o_start_with_knobs <- function(h2o_mem, h2o_threads, quiet = TRUE) {
    if (!requireNamespace("h2o", quietly = TRUE)) {
      stop("Package 'h2o' is required. Install it first.", call. = FALSE)
    }
    nthreads_final <- if (!is.null(h2o_threads) && !is.na(h2o_threads)) as.integer(h2o_threads) else -1L
    mem_final      <- if (!is.null(h2o_mem) && nzchar(h2o_mem)) h2o_mem else NULL

    existing <- try(h2o::h2o.getConnection(), silent = TRUE)
    need_restart <- inherits(existing, "H2OConnection") && (!is.null(mem_final) || !is.null(h2o_threads))

    if (need_restart) {
      suppressWarnings(try(h2o::h2o.shutdown(prompt = FALSE), silent = TRUE))
      for (i in seq_len(120L)) {
        Sys.sleep(0.25)
        probe <- try(h2o::h2o.getConnection(), silent = TRUE)
        if (inherits(probe, "try-error") || !inherits(probe, "H2OConnection")) break
      }
    }

    if (is.null(mem_final)) {
      conn <- h2o::h2o.init(nthreads = nthreads_final)
    } else {
      conn <- h2o::h2o.init(max_mem_size = mem_final, nthreads = nthreads_final)
    }
    if (quiet) try(h2o::h2o.no_progress(), silent = TRUE)
    invisible(conn)
  }

  h2o_conn <- h2o_start_with_knobs(
    h2o_mem     = opt$`h2o-mem`,
    h2o_threads = if (!is.na(opt$`h2o-threads`)) opt$`h2o-threads` else NULL,
    quiet       = !opt$quiet
  )

  # === Progress bar ==========================================================
  total_cols <- max(length(eligible), 1L)
  pb <- cli::cli_progress_bar("Imputing (DRF)", total = total_cols)
  cli::cli_progress_update(id = pb, set = 0)

  # Timer for MODEL RUN ONLY (fit/apply)
  t_model_start <- Sys.time()

  hook <- if (length(eligible)) {
    function() cli::cli_progress_update(id = pb)
  } else {
    NULL
  }

  out <- imputeflow::impute_h2o_drf_fit_apply(
    df,
    cols                     = eligible,
    exclude_predictors       = excl,
    train_rows               = train_rows,
    ntrees                   = opt$ntrees,
    max_depth                = opt$`max-depth`,
    min_rows                 = opt$`min-rows`,
    sample_rate              = opt$`sample-rate`,
    col_sample_rate_per_tree = opt$`col-sample-rate-per-tree`,
    balance_classes          = opt$`balance-classes`,
    seed                     = opt$seed,
    round_digits             = opt$round,   # 0 = integer rounding; NA = no rounding
    h2o_threads              = if (!is.na(opt$`h2o-threads`)) opt$`h2o-threads` else NULL,
    h2o_mem                  = opt$`h2o-mem`,
    nfolds                   = as.integer(opt$nfolds %||% 0L),
    fold_assignment          = opt$`fold-assignment` %||% "AUTO",
    verbose                  = FALSE,
    progress_hook            = hook,
    h2o_connection           = h2o_conn
  )

  if (!length(eligible)) cli::cli_progress_update(id = pb)
  cli::cli_progress_done(id = pb)

  # Compute/print model duration
  dt_secs <- as.numeric(difftime(Sys.time(), t_model_start, units = "secs"))
  if (dt_secs < 60) {
    cli::cli_alert_success("Completed DRF in {.num {round(dt_secs, 1)}}s.")
  } else {
    mins <- floor(dt_secs / 60)
    secs <- round(dt_secs %% 60)
    cli::cli_alert_success("Completed DRF in {.num {mins}}m {.num {secs}}s.")
  }

  # Restore stdout BEFORE writing CSV so redirection works
  if (!did_redirect_stop) {
    redirect_stop(state)
    did_redirect_stop <- TRUE
  }
  write_stdout_csv(out, verbose = !opt$quiet)

  if (isTRUE(opt$`h2o-shutdown`)) {
    tryCatch(h2o::h2o.shutdown(prompt = TRUE), error = function(e) NULL)
  }
}

dispatch <- list()
if (exists("run_mean",   mode = "function")) dispatch$mean   <- run_mean
if (exists("run_median", mode = "function")) dispatch$median <- run_median
if (exists("run_mode",   mode = "function")) dispatch$mode   <- run_mode
if (exists("run_knn",    mode = "function")) dispatch$knn    <- run_knn
if (exists("run_drf",    mode = "function")) dispatch$drf    <- run_drf

if (method %in% names(dispatch)) {
  dispatch[[method]]()
} else {
  cli::cli_alert_danger("Unknown or unavailable method: {method}")
  quit(status = 2)
}